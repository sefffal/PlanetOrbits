var documenterSearchIndex = {"docs":
[{"location":"symbolics/#Symbolic-Manipulation","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"","category":"section"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"The Symbolics.jl package works fairly well out of the box with PlanetOrbits.jl. You can create fully or partially symbolic VisualOrbit and/or solve for orbits at a time or true anomaly given by a symbolic t. This could come in use in a few scenarios. For example, if you have an orbit with all parameters known except inclination, you could construct a set of elements with i as a symbolic variable. Solving the orbit using orbitsolve would then return a solution with simplified symbolic expressions of i that can be evaluated very efficiently for different values. N.B. this approach is quite messy for a symbolic e since Kepler's equation is trancendental.","category":"page"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"There is some support for using the Symbolics.jl package. You can create symbolic variables and trace most of the functions defined in this package to get symbolic expressions.  This is a little slow, and I'm not sure of the applications, but it's neat that it works.","category":"page"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"using Symbolics\n@variables t\nexpr = radvel(elements, t);","category":"page"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"This works with the VisualOrbit constructors as well if you want to create a full symbolic set of elements.","category":"page"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [PlanetOrbits]","category":"page"},{"location":"api/#PlanetOrbits.AbstractOrbit","page":"API","title":"PlanetOrbits.AbstractOrbit","text":"AbstractOrbit\n\nRepresents a orbit. Contains all the information to calculate the location of a planet at a given time, true anomaly, eccentric anomaly, or mean anomaly. Different concrete implementations of AbstractOrbit contain varying amounts of information.\n\nBasic information about the orbit can be queried using functions like period(orbit).\n\nOrbits can be solved using functions like orbitsolve(orb).\n\nSee: RadialVelocityOrbit, KepOrbit, VisualOrbit\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.AbstractOrbitSolution","page":"API","title":"PlanetOrbits.AbstractOrbitSolution","text":"AbstractOrbitSolution\n\nRepresents the solution of an orbit. Contains all the information of an AbstractOrbit, plus information necessary to uniquely locate a planet.\n\nThe solution can be queried using a variety of functions such as radvel(solution).\n\nThe API for creating orbit solutions it not considered public as the fields may change between minor versions. Instead, create solutions only through the public orbitsolve and orbitsolve_... functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.Auto","page":"API","title":"PlanetOrbits.Auto","text":"PlanetOrbits.Auto()\n\nAutomatic choice of Kepler solver algorithm. Currently defaults to PlanetOrbits.Markley()\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.Goat","page":"API","title":"PlanetOrbits.Goat","text":"PlanetOrbits.Goat()\n\nKepler solver implementation from https://arxiv.org/abs/2103.15829 and https://github.com/oliverphilcox/Keplers-Goat-Herd\n\nIt is here for comparison purposes only. In general, Markley() is more performant and accurate.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.KepOrbit","page":"API","title":"PlanetOrbits.KepOrbit","text":"KepOrbit(\n    a, # semi-major axis [AU]\n    e, # eccentricity\n    i, # inclination [rad]\n    ω, # argument of periapsis [rad]\n    Ω, # longitude of ascending node [rad]\n    τ, # epoch of periastron passage at MJD=0\n    M, # mass of primary [M⊙]\n)\n\nRepresents the Keplerian elements of a secondary body orbiting a primary. Values can be specified by keyword argument or named tuple for convenience.\n\nSee also KepOrbitDeg for a convenience constructor accepting units of degrees instead of radians for i, ω, and Ω.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.Markley","page":"API","title":"PlanetOrbits.Markley","text":"PlanetOrbits.Markley()\n\nKepler solver implementation from AstroLib, based on Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI:10.1007/BF00691917). \n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionKep","page":"API","title":"PlanetOrbits.OrbitSolutionKep","text":"Represents a KepOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionRadialVelocity","page":"API","title":"PlanetOrbits.OrbitSolutionRadialVelocity","text":"Represents a RadialVelocityOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionThieleInnes","page":"API","title":"PlanetOrbits.OrbitSolutionThieleInnes","text":"Represents a ThieleInnesOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionVisual","page":"API","title":"PlanetOrbits.OrbitSolutionVisual","text":"Represents a VisualOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.RadialVelocityOrbit","page":"API","title":"PlanetOrbits.RadialVelocityOrbit","text":"RadialVelocityOrbit(a, e, ω, τ, M)\n\nRepresents an orbit of a planet with only the information retrievable from radial velocity measurements. That is, without inclination, longitude of ascending node, or distance to the system.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.RootsMethod","page":"API","title":"PlanetOrbits.RootsMethod","text":"PlanetOrbits.RootsMethod(method::Roots.PlanetOrbits.Roots.AbstractUnivariateZeroMethod, kwargs...)\n\nWraps a root finding method from Roots.jl. Requires Roots to be loaded first. You can also pass keyword arguments that will be forwarded to Roots to control the tolerance.\n\nExamples:\n\nmethod = PlanetOrbits.RootsMethod(Roots.Newton())\nmethod = PlanetOrbits.RootsMethod(Roots.Thukral5B())\nmethod = PlanetOrbits.RootsMethod(Roots.Bisection())\nmethod = PlanetOrbits.RootsMethod(Roots.A42())\nmethod = PlanetOrbits.RootsMethod(Roots.Newton(), rtol=1e-3, atol=1e-3)\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.ThieleInnesOrbit","page":"API","title":"PlanetOrbits.ThieleInnesOrbit","text":"ThieleInnesOrbit(e, τ, M, plx, A, B, F, G)\n\nRepresents a visual orbit of a planet using Thiele-Innes orbital elements. Convertable to and from a VisualOrbit. This parameterization does not have the issue that traditional angular parameters have where the argument of periapsis and longitude of ascending node become undefined for circular and face on orbits respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.VisualOrbit","page":"API","title":"PlanetOrbits.VisualOrbit","text":"VisualOrbit(\n    a, # semi-major axis [AU]\n    e, # eccentricity\n    i, # inclination [rad]\n    ω, # argument of periapsis [rad]\n    Ω, # longitude of ascending node [rad]\n    τ, # epoch of periastron passage at MJD=0\n    M, # mass of primary [M⊙]\n    plx, # parallax [mas]; defines the distance to the primary\n)\n\nRepresents the Keplerian elements of a secondary body orbiting a primary. Values can be specified by keyword argument or named tuple for convenience.\n\nSee also VisualOrbitDeg for a convenience constructor accepting units of degrees instead of radians for i, ω, and Ω.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.KepOrbitDeg-NTuple{7, Any}","page":"API","title":"PlanetOrbits.KepOrbitDeg","text":"KepOrbitDeg(a, e, i, ω, Ω, τ, M)\n\nA convenience function for constructing KepOrbit where i, ω, and Ω are provided in units of degrees instead of radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.VisualOrbitDeg-NTuple{8, Any}","page":"API","title":"PlanetOrbits.VisualOrbitDeg","text":"VisualOrbitDeg(a, e, i, ω, Ω, τ, M, plx)\n\nA convenience function for constructing VisualOrbit where i, ω, and Ω are provided in units of degrees instead of radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.acceleration-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.acceleration","text":"acceleration(elem, t)\n\nGet the instantaneous acceleration [mas/year^2] of the secondary at the time t [days].\n\nacceleration(o)\n\nGet the instantaneous acceleration [mas/year^2] of the secondary from an instance of AbstractOrbitSolution.\n\nacceleration(elem, t, M_planet)\n\nGet the instantaneous acceleration [mas/year^2] of  the primary in at the time t [days]. The units of M_planet and elem.M must match.\n\nacceleration(o)\n\nGet the instantaneous acceleration [mas/year^2] of the primary from an instance of AbstractOrbitSolution. The units of M_planet and elem.M must match.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.astuple-Tuple{KepOrbit}","page":"API","title":"PlanetOrbits.astuple","text":"astuple(elements)\n\nReturn the parameters of a KepOrbit value as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.astuple-Tuple{VisualOrbit}","page":"API","title":"PlanetOrbits.astuple","text":"astuple(elements)\n\nReturn the parameters of a VisualOrbit value as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.decoff","page":"API","title":"PlanetOrbits.decoff","text":"decoff(elem, t)\n\nGet the offset [mas] from the primary body in Declination at the time t [days].\n\ndecoff(elem, t)\n\nGet the offset [mas] from the primary body in Declination from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.distance","page":"API","title":"PlanetOrbits.distance","text":"distance(elem)\n\nDistance to the system [pc].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.eccanom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.eccanom","text":"eccanom(orbit, t)\n\nGet the eccentric anomaly [radians] of the secondary at the time t [days].\n\neccanom(o)\n\nGet the eccentric anomaly [radians] of the secondary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.meananom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.meananom","text":"meananom(orbit, t)\n\nGet the mean anomaly [radians] of the secondary at the time t [days].\n\nmeananom(o)\n\nGet the mean anomaly [radians] of the secondary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.meanmotion","page":"API","title":"PlanetOrbits.meanmotion","text":"meanmotion(elem)\n\nMean motion [rad/year].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.mjd-Tuple{AbstractString}","page":"API","title":"PlanetOrbits.mjd","text":"mjd(\"2020-01-01\")\n\nGet the modfied julian day of a date, or in general a UTC timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.mjd-Tuple{}","page":"API","title":"PlanetOrbits.mjd","text":"mjd()\n\nGet the current modified julian day of right now.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.mjd2date-Tuple{Any}","page":"API","title":"PlanetOrbits.mjd2date","text":"mjd2date(modified_julian)\n\nGet a Date value from a modfied julian day, rounded to closest day\n\nExamples\n\njulia> mjd2date(59160.8)\n2020-11-08\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbit-Tuple{}","page":"API","title":"PlanetOrbits.orbit","text":"orbit(...)\n\nConstruct an orbit from the provided keyword arguments. Will automatically select a subclass of AbstractOrbit based on the information provided. This is a convenience function that is not type stable and should not be used in performance sensitive contexts. Instead, call one of the concrete constructors KepOrbit, VisualOrbit, or RadialVelocityOrbit directly. This function logs the kind of elements created so that it's easy to select the correct constructor.\n\nRequired arguments:\n\na: semi-major axis [AU]\nM: mass of primary [M⊙]\n\nOptional arguments:\n\nτ: epoch of periastron passage at MJD=0, default=0\ne: eccentricity, default=0\nω: argument of periapsis [rad], default=0\ni: inclination [rad]\nΩ: longitude of ascending node [rad]\nplx: parallax [mas]; defines the distance to the primary\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbitsolve","page":"API","title":"PlanetOrbits.orbitsolve","text":"orbitsolve(elements, t, method=Auto())\n\nGiven a set of orbital elements with a time t in days, get the position and velocity of the secondary body (e.g. planet around a star).\n\nThis will output a struct that is a subtype of AbstractOrbitSolution which we can then query with raoff, decoff, radvel, etc.\n\nYou can also calculate those quanitities individually (see their docstrings)  but if you need more than one, it is most efficient to save the orbit solution once.\n\nNote: these calculations use the small angle approximation, so are only accurate when  the star is much further way from the observer than the secondary is from the primary.\n\nSee also: orbitsolve_ν,  orbitsolve_meananom,  orbitsolve_eccanom, projectedseparation, raoff, decoff, radvel, propmotionanom.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.orbitsolve_eccanom-Tuple{AbstractOrbit, Any}","page":"API","title":"PlanetOrbits.orbitsolve_eccanom","text":"orbitsolve_eccanom(elements, EA)\n\nSame as orbitsolve, but solves orbit for a given eccentric anomaly instead of time.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbitsolve_meananom-Tuple{AbstractOrbit, Any}","page":"API","title":"PlanetOrbits.orbitsolve_meananom","text":"orbitsolve_meananom(elements, MA)\n\nSame as orbitsolve, but solves orbit for a given mean anomaly instead of time.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbitsolve_ν","page":"API","title":"PlanetOrbits.orbitsolve_ν","text":"orbitsolve_ν(elem, ν)\n\nSolve a keplerian orbit from a given true anomaly [rad]. See orbitsolve for the same function accepting a given time.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.orbitsolve_ν-2","page":"API","title":"PlanetOrbits.orbitsolve_ν","text":"orbitsolve_ν(elem, ν, EA)\n\nSolve an orbit from a given true anomaly [rad]. See orbitsolve for the same function accepting a given time. Can optionally pass eccentric anomaly (EA) if already computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.periastron","page":"API","title":"PlanetOrbits.periastron","text":"periastron(elements, tref=58849)\n\nCompute the MJD of periastron passage most recently after the reference epoch tref. N.B. mjd of 58849 = 2020-01-01\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.period","page":"API","title":"PlanetOrbits.period","text":"period(elem)\n\nPeriod of an orbit [days].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posangle-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.posangle","text":"posangle(elem, t)\n\nCalculate the position angle [rad] of the secondary about its primary from our perspective at the time t [days].\n\nposangle(o)\n\nCalculate the position angle [rad] of the secondary about its primary from our perspective from an instance of AbstractOrbitSolution.\n\nposangle(elem, t, M_planet)\n\nCalculate the position angle [rad] of the secondary about its primary from our perspective at the time t [days]. In this case only, the value of M_planet can be arbitrary.\n\nposangle(o, M_planet)\n\nCalculate the position angle [rad] of the primary  from our perspective from an instance of AbstractOrbitSolution. In this case only, the value of M_planet can be arbitrary.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.posx","page":"API","title":"PlanetOrbits.posx","text":"posx(elem, t)\n\nGet the offset [AU] from the primary body at the time t [days].\n\nposx(elem, t)\n\nSame as above, but from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posy","page":"API","title":"PlanetOrbits.posy","text":"posy(elem, t)\n\nGet the offset [AU] from the primary body at the time t [days].\n\nposy(o)\n\nSame as above, but from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posz","page":"API","title":"PlanetOrbits.posz","text":"posz(elem, t)\n\nGet the offset [AU] from the primary body at the time t [days].\n\nposz(o)\n\nSame as above, but from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.projectedseparation-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.projectedseparation","text":"projectedseparation(elem, t)\n\nCalculate the projected separation [mas] of the secondary from its primary at the time t [days].\n\nprojectedseparation(o)\n\nCalculate the projected separation [mas] of the secondary from its primary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.propmotionanom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.propmotionanom","text":"propmotionanom(elem, t)\n\nGet the instantaneous proper motion anomaly [mas/year] of the secondary at the time t [days].\n\npropmotionanom(o)\n\nGet the instantaneous proper motion anomaly [mas/year] of the secondary from an instance of AbstractOrbitSolution.\n\npropmotionanom(elem, t, M_planet)\n\nGet the instantaneous proper motion anomaly [mas/year] of  the primary in at the time t [days]. The units of M_planet and elem.M must match.\n\npropmotionanom(o, M_planet)\n\nSame as above, but from an orbit solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.radvel","page":"API","title":"PlanetOrbits.radvel","text":"radvel(elem, t)\n\nGet the radial velocity [m/s] of the secondary along the line of sight at the time t [days].\n\nradvel(o)\n\nGet the radial velocity [m/s] of the secondary along the line of sight from an instance of AbstractOrbitSolution.\n\nradvel(elem, t, M_planet)\n\nGet the radial velocity [m/s] of the primary along the line of sight at the time t [days]. The units of M_planet and elem.M must match.\n\nradvel(o, M_planet)\n\nGet the radial velocity [m/s] of the primary along the line of sight from an AbstractOrbitSolution. The units of M_planet and elem.M must match.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.raoff","page":"API","title":"PlanetOrbits.raoff","text":"raoff(elem, t)\n\nGet the offset [mas] from the primary body in Right Ascension at the time t [days].\n\nraoff(o)\n\nGet the offset [mas] from the primary body in Right Ascension  from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.semiamplitude","page":"API","title":"PlanetOrbits.semiamplitude","text":"semiamplitude(elem)\n\nRadial velocity semiamplitude [m/s].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.trueanom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.trueanom","text":"trueanom(orbit, t)\n\nGet the true anomaly [radians] of the secondary at the time t [days].\n\ntrueanom(o)\n\nGet the true anomaly [radians] of the secondary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.years2mjd-Tuple{Any}","page":"API","title":"PlanetOrbits.years2mjd","text":"years2mjd()\n\nConvert from fractional years (e.g. 1995.25) into modified julian date.\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Units-and-Conventions","page":"Conventions","title":"Units & Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The main constructor, VisualOrbit, accepts the following parameters:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"a: Semi-major axis in astronomical units (AU)\ni: Inclination in radians\ne: Eccentricity in the range [0, 1)\nτ: Epoch of periastron passage, in fraction of orbit [0,1]\nM: Graviataion parameter of the central body, expressed in units of Solar mass.\nω: Argument of periastron\nΩ: Longitude of the ascending node, radians.\nplx: Distance to the system expressed in milliarcseconds of parallax.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Thee parameter τ represents the epoch of periastron passage as a  fraction of the planet's orbit between 0 and 1. This follows the same convention as Orbitize! and you can read more about their choice in ther FAQ.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Parameters can either be specified by position or as keyword arguments (but not a mix).","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"There is also a convenience constructor VisualOrbitDeg that accepts i, ω, and Ω in units of degrees instead of radians.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"(Image: )","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This diagram shows a circular (gray), inclined (blue), and inclined eccentric (green) orbits described using the conventions of this package.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The x variable increases to the left in the plane of the sky, consistent with right ascension that increases towards the East. The y coordinate increases upwards towards the North. The z coordinate increases away from the observer.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The ascending node is measured CCW in the plane of the sky starting from the y (North) axis.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The location of the planet along its ellipse is measured along the green ellipse starting from periastron. The parameter tau describes what fraction of the orbit the planet had completed at a chosen reference epoch, and therefore sets the location of the planet at a given time.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"See this PDF for a detailed derivation of projected position, velocity, and acceleration from these coordinates: Derivation.pdf","category":"page"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first step to using DirectDetections.jl is to install Julia. If you're used to Python, don't worry –- Julia is easy to install, and you won't need to code anything other than changing your input data.","category":"page"},{"location":"getting-started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Visit the julialang.org Downloads page, and select the latest stable version for your operating system. Currently, this is 1.7.0. Click the [help] links next to your operating system if you require more detailed instructions.","category":"page"},{"location":"getting-started/#Installing-PlanetOrbits","page":"Getting Started","title":"Installing PlanetOrbits","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Normally, Julia packages are installed from the General registry. Since PlanetOrbits isn't quite ready for prime time, it requires one extra step to add an additional registry.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Start julia in a terminal by running julia\nType ] to enter package-mode (see Julia documentation for more details)\nType up to setup the General registry if this is your first time using Julia.\nType registry add https://github.com/sefffal/DirectRegistry\nType add PlanetOrbits","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you would like to visualize your results, you can also install the Plots package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Type add Plots","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This will take a little while to download all the required packages and precompile for your system.","category":"page"},{"location":"getting-started/#Plotting-your-first-orbit","page":"Getting Started","title":"Plotting your first orbit","text":"","category":"section"},{"location":"plots/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"This package defines Plots.jl recipes for orbits and orbit solutions. At its most basic, you can simply call plot on the object. The kind  of plot will be based on the type of object. You can pass the kind argument to control what plot is generated.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Examples:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"using PlanetOrbits, Plots\norb = orbit(\n    a=1.0,\n    M=1.0,\n)\nplot(orb) # defaults to kind=:radvel","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"orb = orbit(\n    a=1.0,\n    M=1.0,\n    i=0.5,\n    Ω=4.5\n)\nplot(orb) # defaults to kind=(:x,:y)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"orb = orbit(\n    a=1.0,\n    M=1.0,\n    i=0.5,\n    Ω=4.5,\n    plx=120.0\n)\nplot(orb) # defaults to kind=:astrom","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"We can override:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=:radvel)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=(:x,:y))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=(:x,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=(:x,:y,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"They all work on a given orbit solution as well:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"sol = orbitsolve(orb, mjd(\"2020-01-01\"))\nplot(sol, kind=:radvel)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(sol, kind=(:x,:y))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(sol, kind=(:x,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(sol, kind=(:x,:y,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Note, in GR the position of the marker in 3D plots is incorrect. Try the plotly() backend instead.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The plots are generated by tracing out the orbit in equal steps of mean anomaly.  Compared to taking equal steps in time, this gives smooth lines even for very highly eccentric orbits.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The plot recipe sets the axes to have default aspect ratios and flips the right-ascension (horizontal) axis to increasing towards the left as it does when viewed in the plane of the sky.","category":"page"},{"location":"plots/#Plotting-multiple-orbits","page":"Plotting","title":"Plotting multiple orbits","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"If you have an array of Keplerian orbits, you can plot them all in one go:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"elements = [VisualOrbitDeg(a=16+0.3i, i=i, e=0.25+0.001i, τ=0, M=1, ω=0, Ω=120, plx=35) for i in 1:1:90]\nplot(elements, color=1)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"This recipe scales down the opacity slightly so that you can see where the orbits overlap. Override by passing alpha=1.","category":"page"},{"location":"plots/#Animations","page":"Plotting","title":"Animations","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"You can use the Plots.jl @gif and @animate macros to create animations using a for loop.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"orb = orbit(a=1.2, e=0.4, M=1.0, ω=π/2, τ=0.0, i=π/4, Ω=0,plx=100)\n@gif for t in range(0, period(orb),length=30)\n    sol = orbitsolve(orb,t,tref=0)\n    plot(\n        plot(sol,kind=(:raoff,:decoff),body=(:primary,:secondary),mass=0.2,legend=false,title=\"astrometry\"),\n        plot(sol,kind=(:pmra,:pmdec),body=(:primary,:secondary),mass=0.2,title=\"proper motion anomaly\"),\n        plot(sol,kind=(:accra,:accdec),body=(:primary,:secondary),mass=0.2,legend=false,title=\"astrometric acceleration\"),\n        plot(sol,kind=(:t,:radvel),body=(:primary,:secondary),mass=0.2,legend=false,title=\"radial velocity\"),\n        lims=:symmetric,\n        framestyle=:box, titlefontsize=10,guidefontsize=7,tickfontsize=7\n    )\nend","category":"page"},{"location":"plots/#Logo","page":"Plotting","title":"Logo","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"To get more ideas for plotting, check out this example which generates an animated version of the logo for this page.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"(Image: orbit logo)","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# Set a plot theme so that the plots appear nicely on dark or light documenter themes\nusing Plots\ntheme(:default;\n        framestyle=:box,\n    )","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This package is structured around a representation of an orbit (PlanetOrbits.AbstractOrbit, and a representation of a \"solved\" orbit (PlanetOrbits.AbstractOrbitSolution).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"You start by creating an orbit with known information, e.g. the semi-major axis and eccentricity. You can then query information from this orbit, like its orbital period, mean motion, or periastron (closest approach). Then, you can \"solve\" the orbit one more times for a given time, eccentric anomaly, or true anomaly.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Let's see how this works.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using PlanetOrbits, Plots\norb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The orbit function accepts many combinations of orbital parameters and returns a subtype of PlanetOrbits.AbstractOrbit.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can now query some basic properties about the orbit:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"period(orb) # orbital period (days)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"meanmotion(orb) # Mean motion (radians/yr)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"periastron(orb) # Epoch of periastron passage (MJD)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"semiamplitude(orb) # radial velocity semi-amplitude (m/s)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can plot the orbit (more on this in Plotting):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(orb)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"And we can solve the orbit for a given orbital location","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sol = orbitsolve_ν(orb, 0.1)        # true anomaly (radians)\nsol = orbitsolve_eccanom(orb, 0.1)  # eccentric anomaly (radians)\nsol = orbitsolve_meananom(orb, 0.1) # mean anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When constructing an orbit, the location of the planet along its orbit can be specified by τ. This is a unitless value between 0 and 1 that represents the fraction of the orbit completed at reference epoch tref which by default is the MJD 58849.0, or 2020-01-01.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    τ=0.2,\n);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can now meaningfully solve the location of the planet at a specific time:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"t = mjd(\"2020-07-15\") # date as in modified julian days.\nsol = orbitsolve(orb, t) # can optionally pass `tref=...` ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can query specifics at this solution:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"trueanom(sol) # true anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"eccanom(sol) # eccentric anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol) # defaults to kind=:radvel for RadialVelocityOrbit","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Notice that we now see a marker at the location found by orbitsolve.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can create an orbit with some eccentricity. If not specified, eccentricity and the argument or periapsis default to 0 for any orbit type.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    τ=0.2,\n    # New:\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n)\nplot(orb) # defaults to kind=:radvel for RadialVelocityOrbit","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"warning: ω convention\nThe convention used in this package is that ω, the argument of periapsis, refers to the secondary body. This is in contrast to the typical standard adopted in the radial velocity literature where ω refers to the primary. You can convert by adding or subtracting 180°.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Since we only provided very minimal information to the orbit function, we've been receiving a RadialVelocityOrbit. This object contains sufficient information to calculate the above radial velocity plots, orbital period, etc., but not the 3D position in space.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Let's create a new orbit with a specified inclination and longitude of ascending node.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    τ=0.2,\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    # New:\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This time we received a full KepOrbit. This has the necessary information to solve the orbit in 2/3D.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(orb) # defaults to kind=(:x,:y) for KepOrbit","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(orb, kind=(:x,:y,:z))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"warning: Cartesian convention\nThe convention used in this package is that x increases to the left (just like right-ascension), and the z increases away from the observer. This means all results are ready to be compared to observations where these conventions are typically used; however, it does mean that the space does not follow the standard right-hand rule.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can solve for a time or location as usual.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sol = orbitsolve(orb, mjd(\"2025-01\"))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"eccanom(sol) # eccentric anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can also query the cartesian position of the planet in AU:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posx(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posy(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posy(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol, kind=:x)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can still of course calculate the radial velocity as well.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"radvel(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol, kind=:radvel)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Finally, we'll specify the parallax distance to the system. This will allow us to plot orbits with angular units as they would appear in the sky from the Earth.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    τ=0.2,\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n    # New:\n    plx=100.0 # parallax distance (milliarcseconds)\n)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sol = orbitsolve(orb, 0.0)\nplot(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"posangle(sol) # position angle offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"projectedseparation(sol) # separation from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"raoff(sol) # right ascension offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"decoff(sol) # declination offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"raoff(sol) # right ascension offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"decoff(sol) # declination offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"pmra(sol) # instantaneous right ascension velocity from barycentre (milliarcseconds/year)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"pmdec(sol) # instantaneous declination velocity from barycentre (milliarcseconds/year)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"accra(sol) # instantaneous right ascension acceleration from barycentre (milliarcseconds/year^2)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"accdec(sol) # instantaneous declination acceleration from barycentre (milliarcseconds/year^2)","category":"page"},{"location":"introduction/#Performance","page":"Introduction","title":"Performance","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The orbit function is a convenience only for interactive use. It is inefficient since it is not type-stable. Instead, one should use one of the orbit constructors directly. For example, instead of ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    τ=0.2,\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n    plx=100.0 # parallax distance (milliarcseconds)\n) # Not type stable","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Use:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = VisualOrbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    τ=0.2,\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n    plx=100.0 # parallax distance (milliarcseconds)\n) # Type stable","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This will also suppress the log message.","category":"page"},{"location":"introduction/#Convenience","page":"Introduction","title":"Convenience","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"All functions described above that apply to orbit solutions can be called directly on an orbit along with a time in days:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n)\nradvel(orb, mjd(\"2025-01-01\"))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"If you need to calculate many different properties, e.g. both x and y position at a given time/location, it is more efficient to calculate the orbit solution a single time.","category":"page"},{"location":"introduction/#Host-calculations","page":"Introduction","title":"Host calculations","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The above calculations treat the planet as a test particle and calculate their displacement/velocity/etc. compared to the two-particle system's barycentre. If you wish to calculate the same properties for the host object, you can additionally supply the mass of the planet.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    i=0.5,\n    Ω=2.5,\n    plx=100.0\n)\nsol = orbitsolve(orb, mjd(\"2025-01-01\"))\n# Secondary radial velocity\nradvel(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# Primary radial velocity\nradvel(sol, 0.1) # 0.1 solar mass secondary","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The following show pairs of results for the secondary and the primary:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posx(sol), PlanetOrbits.posx(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"radvel(sol), radvel(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"raoff(sol), raoff(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"accra(sol), accra(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"projectedseparation(sol), projectedseparation(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"posangle(sol), posangle(sol, 0.1)","category":"page"},{"location":"#PlanetOrbits.jl","page":"Home","title":"PlanetOrbits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tools for solving Keplerian orbits in the context of direct imaging. The primary use case is mapping Keplerian orbital elements into Cartesian coordinates at different times. A Plots.jl recipe is included for easily plotting orbits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Among other values, it calculates the projected positions of planets, as well as stellar radial velocity and proper motion anomaly. It's a great tool for visualizing different orbits (see examples) and generating nice animations (e.g. with Plots or Luxor.jl).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has been designed for good performance and composability with a wide range of packages in the Julia ecosystem, including ForwardDiff. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To fit orbits to observations, see Octofitter.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also AstroImages.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video src=\"assets/51-eri-orbit.mp4\" autoplay loop width=300 height=300>","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"introdcution.md\", \"plots.md\", \"image-warping.md\"]\nDepth = 5","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\", \"conventions.md\", \"kepler.md\"]\nDepth = 5","category":"page"},{"location":"image-warping/#Image-Warping","page":"Image Warping","title":"Image Warping","text":"","category":"section"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"warning: Warning\nThis functionality is currently not working and could use some attention in the form of pull request.","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"If you have an image of a system, you can warp the image as if each pixel were a test particle following Kepler's laws.  This is an easy way to see what a disk or a system of planets would look like at a time other than when it was captured.","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"To make this possible, PlanetOrbits.jl can create OrbitalTransformation objects. These follow the conventions set out in CoordinateTransformations.jl and are compatible with ImageTransformations.jl.","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"Example:","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"using ImageTransformations, AstroImages, CoordinateTransformations\not = OrbitalTransformation(\n    i = 0.3,\n    e = 0.0,\n    M = 1.0,\n    ω = 0.5,\n    Ω = 0.5,\n    plx = 300.0,\n    \n    platescale=10.0, # mas/px\n    dt = 3*365.25 # days forward in time\n)\n\nimg = load(\"input.fits\")\n\ntform_centered = ImageTransformations.recenter(ot, ImageTransformations.center(img))\nimg_future = warp(img_centered, ot, axes(img_centered))\n\n# Display with AstroImages.jl\nimview([img; img_future], cmap=:seaborn_icefire_gradient)","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"Before, and After Orbital Transformation","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"(Image: image)","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"Note the arguments platescale and dt are required, but a and τ are not. The position of the pixel in X/Y space uniquely determines the semi-major axis and epoch of periastron passage when the rest of the orbital parameters are known. platescale in units of milliarseconds/pixel is necessary to get the overall scale of the transform correct. This is because an orbital transformation is not linear (and therefore, care must be taken when composing an OrbitalTransformation with other CoordinateTransformations). Scaling an image will change the amount of rotation that occurs at each separation. dt is the the amount of time in days to project the image forward. It can also be negative to project the image into the past. ","category":"page"},{"location":"kepler/#Kepler-Solvers","page":"Kepler Solvers","title":"Kepler Solvers","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The heart of this package is being able to take a set of Keplerian elements and output relative positions, velocities, etc.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"This normaly requires solving Kepler's equation numerically. This package supports a multitude of solver algorithms that can be passed to orbitsolve:","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"PlanetOrbits.Auto\nPlanetOrbits.Markley\nPlanetOrbits.Goat\nPlanetOrbits.RootsMethod","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The last of these RootsMethod, allows one to substitute any algorithm from the Roots.jl package. These include many different classical and modern root finding algorithms.chosen precision, including artibrary precision BigFloats. Using big floats with, for example, Roots.PlanetOrbits.Thukral5B and a tight tolerenace, allows you to solve orbits up to arbitrary precision.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The default choice is Auto, which currently selects Markley for all cases. The Markley algorithm is very fast, reasonably accurate, and always converges, making it a good default choice.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The Markley algorithm is a tweaked version of the algorithm from AstroLib.jl. It is non-iterative and converges with less than 1e-15 relative error across the full range of e between 0 and 1. On my laptop, this solves for a single eccentric anomaly in just 71 ns. Since it is implemented in pure Julia, there is no overhead from calling into a C or Cython compiled function and no need for vectorization.","category":"page"},{"location":"kepler/#Examples","page":"Kepler Solvers","title":"Examples","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"using PlanetOrbits, BenchmarkTools\norb = orbit(a=1.2, e=0.1, M=1.0, ω=1.4, τ=0.5)\nt = mjd(\"2025-06-23\")\n@benchmark orbitsolve(orb, t, PlanetOrbits.Markley())","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.Goat())","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"using Roots\n@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Newton()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"using Roots\n@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Thukral3B()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.A42()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Bisection()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.SuperHalley()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Brent()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Order2()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.AlefeldPotraShi()))","category":"page"},{"location":"kepler/#High-precision","page":"Kepler Solvers","title":"High precision","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"You can solve Kepler's equation in high precision using big floats and tightening the tolerance on the solver.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"orb_big = orbit(a=big(1.2), e=big(0.1), M=big(1.0), ω=big(1.4), τ=big(0.5))\nsol = orbitsolve(orb_big, big(t), PlanetOrbits.RootsMethod(Roots.Thukral5B(),rtol=1e-30,atol=1e-30,))\nradvel(sol)","category":"page"},{"location":"kepler/#Comparison","page":"Kepler Solvers","title":"Comparison","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"(Image: ) (Image: )","category":"page"}]
}
